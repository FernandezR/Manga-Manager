# common
import random
import re
import tkinter as tk
import unittest
from zipfile import ZipFile

from ConvertersLib.epub2cbz import epub2cbz
from CoverManagerLib.cbz_handler import SetCover
from CoverManagerLib.models import cover_process_item_info
# Volume Manager
from MangaManager.VolumeManager import VolumeManager
from MangaManager.VolumeManager.models import ChapterFileNameData
# Manga Tagger
from MetadataManagerLib import MetadataManager
from MetadataManagerLib.cbz_handler import *

# Epub2Cbz

# Cover Manager
comicinfo_23 = """
<ComicInfo xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   <!--Generated by Manga Tagger, an Endless Galaxy Studios project-->
   <Series>Maou ni Natta node, Dungeon Tsukutte Jingai Musume to Honobono suru</Series>
   <Number>23</Number>
   <Count>1</Count>
   <Summary/>
   <Year>2018</Year>
   <Month>5</Month>
   <Writer>Ryuuyuu</Writer>
   <Penciller>Note Toono</Penciller>
   <Inker>Note Toono</Inker>
   <Colorist>Note Toono</Colorist>
   <Letterer>Note Toono</Letterer>
   <CoverArtist>Note Toono</CoverArtist>
   <Publisher>Dra-Dra-Dragon Age</Publisher>
   <Genre>Fantasy</Genre>
   <Web>https://myanimelist.net/manga/115200/Maou_ni_Natta_node_Dungeon_Tsukutte_Jingai_Musume_to_Honobono_suru</Web>
   <LanguageISO>en</LanguageISO>
   <Manga>Yes</Manga>
   <Notes>Scraped metadata from AniList and MyAnimeList (using Jikan API) on 2021-12-24 12:38 PM EST</Notes>
</ComicInfo>
"""
comicinfo_24 = """
<ComicInfo xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   <!--Generated by Manga Tagger, an Endless Galaxy Studios project-->
   <Series>Maou ni Natta node, Dungeon Tsukutte Jingai Musume to Honobono suru</Series>
   <Number>24</Number>
   <Count>1</Count>
   <Summary/>
   <Year>2018</Year>
   <Month>5</Month>
   <Writer>Ryuuyuu</Writer>
   <Penciller>Note Toono</Penciller>
   <Inker>Note Toono</Inker>
   <Colorist>Note Toono</Colorist>
   <Letterer>Note Toono</Letterer>
   <CoverArtist>Note Toono</CoverArtist>
   <Publisher>Dra-Dra-Dragon Age</Publisher>
   <Genre>Fantasy</Genre>
   <Web>https://myanimelist.net/manga/115200/Maou_ni_Natta_node_Dungeon_Tsukutte_Jingai_Musume_to_Honobono_suru</Web>
   <LanguageISO>en</LanguageISO>
   <Manga>Yes</Manga>
   <Notes>Scraped metadata from AniList and MyAnimeList (using Jikan API) on 2021-12-24 12:38 PM EST</Notes>
</ComicInfo>
"""
path_23 = r"tests/Sample CBZ Chapter 23.cbz"
path_24 = r"tests/Sample CBZ Chapter 24.cbz"
sample_cover = r"tests/SAMPLE_COVER.jpg"
test_path = path_23
test_path = test_path
sample_cover = sample_cover

original_cleanup_var1 = ""
final_cleanup_var1 = ""


class ComicInfoTester(unittest.TestCase):
    """
    The purpose of this test is to check ComicInfo class is properly edited.
    It's a automatically generated class with changes
    """

    def setUp(self) -> None:
        self.comicinfo = ComicInfo.ComicInfo()
        self.comicinfo.set_AgeRating(ComicInfo.AgeRating.RATING_PENDING)

    def test_manualModifications(self):
        # @classmethod
        # def list(cls):
        #     return list(map(lambda c: c.value, cls))
        self.assertTrue(ComicInfo.AgeRating.list())
        self.assertTrue(ComicInfo.ComicPageType.list())
        ComicInfo.parseString(comicinfo_23, silence=True, print_warnings=False, doRecover=True)


initial_dir_count = 0


class MetadataEditorTests(unittest.TestCase):
    def setUp(self) -> None:
        self.initial_dir_count = len(os.listdir(os.path.dirname(test_path)))
        first_file_chapter = ""
        second_file_chapter = ""

    def test_replace_file(self):
        """The number of files read in the output cbz must be the same as in the input (check needed to not end up with empty unreadable files"""
        self.assertTrue(True)
        return
        # global initial_dir_count
        # initial_dir_count = len(os.listdir(os.path.dirname(test_path)))

        root = tk.Tk()
        test_files = [path_23, path_24]
        opened_cbz = ReadComicInfo(path_23, ignore_empty_metadata=True)
        number_files_preprocess_1 = opened_cbz.total_files
        opened_cbz = 0  # reset so file gets closed
        opened_cbz = ReadComicInfo(path_24, ignore_empty_metadata=True)
        number_files_preprocess_2 = opened_cbz.total_files
        opened_cbz = 0  # reset so file gets closed
        random_int = random.random()
        app = MetadataManager.App(root)

        app.create_loadedComicInfo_list(test_files)
        for widget_var in app.widgets_var:
            if isinstance(widget_var, tk.StringVar):
                widget_var.set(f"This is: {str(widget_var)} modified_ randint:{random_int}")
            else:
                widget_var.set(random_int)
        app.input_1_summary_obj.set(f"This is the summary_{random_int}")

        # Chapter number must be kept when handling multiple files they can't be the same.

        app.parseUI_toComicInfo()
        app.saveComicInfo()  # This writes file

        opened_cbz = ReadComicInfo(path_23)
        number_files_postprocess = opened_cbz.total_files
        xml_postprocess = opened_cbz.to_ComicInfo()
        if not self.first_file_chapter:
            self.first_file_chapter = xml_postprocess.get_Number()

        # self.assertAlmostEqual(number_files_preprocess, number_files_postprocess)
        print(f"Asserting first file {number_files_preprocess_1} vs {number_files_postprocess}, delta 1")
        self.assertAlmostEqual(number_files_preprocess_1, number_files_postprocess, delta=1)

        opened_cbz = ReadComicInfo(path_24)
        number_files_postprocess = opened_cbz.total_files
        xml_postprocess = opened_cbz.to_ComicInfo()
        second_file_chapter = xml_postprocess.get_Number()
        # self.assertAlmostEqual(number_files_preprocess, number_files_postprocess)
        print(f"Asserting second file {number_files_preprocess_2} vs {number_files_postprocess}, delta 1")
        self.assertAlmostEqual(number_files_preprocess_2, number_files_postprocess, delta=1)

        print(f"Asserting Chapter number. (they can't match) '{self.first_file_chapter}' vs '{second_file_chapter}'")
        if not (self.first_file_chapter and second_file_chapter == ""):
            self.assertNotEqual(self.first_file_chapter, second_file_chapter)

        # app.input_1_summary_obj.set(f"This is the summary_{random_int}")

    def test_modifying_values(self):
        root = tk.Tk()
        random_int = random.random()
        app: MetadataManager.App = MetadataManager.App(root)
        test_files = [path_23, path_24]

        app.create_loadedComicInfo_list(test_files)
        for widget_var in app.widgets_var:
            # if str(widget_var) ==
            if isinstance(widget_var, tk.StringVar):
                widget_var.set(f"This is: {str(widget_var)} modified_ randint:{random_int}")
            elif isinstance(widget_var, tk.OptionMenu):
                continue
            else:
                widget_var.set(random_int)
        # app.input_1_summary_obj.set(f"This is the summary_{random_int}")

        # Chapter number must be kept when handling multiple files they can't be the same.
        app.do_save_UI()
        # Reopen each file and check that they match edited values
        app = MetadataManager.App(root)
        app.create_loadedComicInfo_list([path_23])
        for widget_var in app.widgets_var:
            if isinstance(widget_var, tk.StringVar):
                print(f"Asserting: {str(widget_var)}")
                if str(widget_var) == "CommunityRating":
                    self.assertEqual('0', widget_var.get())
                    continue
                try:
                    self.assertEqual(f"This is: {str(widget_var)} modified_ randint:{random_int}", widget_var.get())
                except tk.TclError:
                    pass


            elif isinstance(widget_var, tk.OptionMenu):
                continue
            elif isinstance(widget_var, tk.IntVar):
                print(f"Asserting: {str(widget_var)}")
                self.assertEqual(int(random_int), widget_var.get())
            else:
                print(f"Asserting: {str(widget_var)}")
                self.assertEqual(random_int, float(widget_var.get()))

    def test_deleteAndRecover(self):
        test_files = [path_23, path_24]
        opened_cbz = ReadComicInfo(path_23, ignore_empty_metadata=True)
        number_files_preprocess_1 = opened_cbz.total_files
        opened_cbz = 0  # reset so file gets closed

        random_int = random.random()

        root = tk.Tk()
        app = MetadataManager.App(root)
        app.create_loadedComicInfo_list([path_23])
        app.deleteComicInfo()

        opened_cbz = ReadComicInfo(path_23, ignore_empty_metadata=True)

        number_files_postprocess = opened_cbz.total_files
        xml_postprocess = opened_cbz.to_ComicInfo()
        second_file_chapter = xml_postprocess.get_Number()
        # Add one more so it asserts that one file was deleted
        print(f"Asserting second file {number_files_preprocess_1} vs {number_files_postprocess}+1, delta 0")
        self.assertAlmostEqual(number_files_preprocess_1, number_files_postprocess + 1, delta=1)

        opened_cbz = WriteComicInfo(LoadedComicInfo(path_23, ComicInfo)).restore()
        opened_cbz = ReadComicInfo(path_23, ignore_empty_metadata=True)
        number_files_postprocess = opened_cbz.total_files
        print(f"File is recovered {number_files_preprocess_1} vs {number_files_postprocess}+1, delta 0")
        self.assertAlmostEqual(number_files_preprocess_1, number_files_postprocess + 1, delta=1)

    def test_zcount_leftover_files(self):
        final_dir_count = len(os.listdir(os.path.dirname(test_path)))
        print(f"Asserting {self.initial_dir_count} vs {final_dir_count}, delta 1")
        self.assertEqual(self.initial_dir_count, final_dir_count)


initial_dir_count = 0


class CoversCbzControllerTester(unittest.TestCase):
    def test_append(self):
        global initial_dir_count
        initial_dir_count = len(os.listdir(os.path.dirname(test_path)))

        with zipfile.ZipFile(test_path, 'r') as zin:
            item_count = len(zin.namelist())
            # print("\n".join(zin.namelist()))
        values_to_process = cover_process_item_info(
            cbz_file=test_path,
            cover_path=sample_cover,
            cover_format="jpg"

        )
        SetCover(values_to_process)

        with zipfile.ZipFile(test_path, 'r') as zin:
            item_count2 = len(zin.namelist())
            # print("\n\n\nNEW RESULT\n ")
            # print("\n".join(zin.namelist()))

        # if item_count == item_count2:
        #     print(f"####\n{item_count}\nSAME CONTENT\n{item_count2}\n####")
        print(f"Asserting {item_count} vs {item_count2}, delta 1")
        self.assertAlmostEqual(item_count, item_count2, delta=1)  # add assertion here

    def test_overwrite(self):
        with zipfile.ZipFile(test_path, 'r') as zin:
            item_count = len(zin.namelist())
            # print("\n".join(zin.namelist()))
        values_to_process = cover_process_item_info(
            cbz_file=test_path,
            cover_path=sample_cover,
            cover_format="jpg",
            coverOverwrite=True

        )
        SetCover(values_to_process)

        with zipfile.ZipFile(test_path, 'r') as zin:
            item_count2 = len(zin.namelist())
            # print("\n\n\nNEW RESULT\n ")
            # print("\n".join(zin.namelist()))

        # if item_count == item_count2:
        #     print(f"####\n{item_count}\nSAME CONTENT\n{item_count2}\n####")
        print(f"Asserting {item_count} vs {item_count2}, delta 1")
        self.assertAlmostEqual(item_count, item_count2, delta=1)  # add assertion here

    def test_delete(self):
        with zipfile.ZipFile(test_path, 'r') as zin:
            item_count = len(zin.namelist())
            # print("\n".join(zin.namelist()))
        values_to_process = cover_process_item_info(
            cbz_file=test_path,
            cover_path=sample_cover,
            cover_format="jpg",
            coverDelete=True

        )
        SetCover(values_to_process)

        with zipfile.ZipFile(test_path, 'r') as zin:
            item_count2 = len(zin.namelist())
            # print("\n\n\nNEW RESULT\n ")
            # print("\n".join(zin.namelist()))

        # if item_count == item_count2:
        #     print(f"####\n{item_count}\nSAME CONTENT\n{item_count2}\n####")
        print(f"Asserting {item_count} vs {item_count2}, delta 1")
        self.assertAlmostEqual(item_count, item_count2, delta=1)  # add assertion here

    def test_zcount_leftover_files(self):
        final_dir_count = len(os.listdir(os.path.dirname(test_path)))
        print(f"Asserting {initial_dir_count} vs {final_dir_count}, delta 1")
        self.assertEqual(initial_dir_count, final_dir_count)


initial_dir_count = 0


class VolumeManagerTester(unittest.TestCase):

    def test_rename(self):
        def get_newFilename(files: list[str], volumeNumber) -> str:
            for cbz_path in files:
                filepath = cbz_path
                filename = os.path.basename(filepath)
                regexSearch = re.findall(r"(?i)(.*)((?:Chapter|CH)(?:\.|\s)[0-9]+[.]*[0-9]*)(\.[a-z]{3})", filename)
                if regexSearch:
                    r = regexSearch[0]
                    file_regex_finds: ChapterFileNameData = ChapterFileNameData(name=r[0], chapterinfo=r[1],
                                                                                afterchapter=r[2], fullpath=filepath,
                                                                                volume=volumeNumber)
                else:
                    regexSearch = re.findall(r"(?i)(.*\s)([0-9]+[.]*[0-9]*)(\.[a-z]{3}$)",
                                             filename)  # TODO: this regex must be improved yo cover more test cases
                    if regexSearch:
                        r = regexSearch[0]
                        file_regex_finds: ChapterFileNameData = ChapterFileNameData(name=r[0], chapterinfo=r[1],
                                                                                    afterchapter=r[2],
                                                                                    fullpath=filepath,
                                                                                    volume=volumeNumber)
                new_file_path = os.path.dirname(filepath)
                newFile_Name = f"{new_file_path}/{file_regex_finds.name} Vol.{volumeNumber} {file_regex_finds.chapterinfo}{file_regex_finds.afterchapter}".replace(
                    "  ", " ")
                return newFile_Name

        #  Prepare and save original values to later assert
        global original_cleanup_var1
        original_cleanup_var1 = test_path
        global initial_dir_count
        global final_dir_count
        initial_dir_count = len(os.listdir(os.path.dirname(test_path)))

        random_vol_number = random.randint(1, 500)
        test_path_dir = os.path.dirname(test_path)

        new_fileName_toAssert = get_newFilename([test_path], random_vol_number)
        aseert_name = os.path.basename(new_fileName_toAssert)
        global final_cleanup_var1
        final_cleanup_var1 = new_fileName_toAssert

        with zipfile.ZipFile(test_path, 'r') as zin:
            initial_dir_count = len(zin.namelist())

        #  Proceed with testing
        root = tk.Tk()
        app = VolumeManager.App(root)
        app.cli_set_volume(random_vol_number)
        app.cli_select_files([test_path])
        app.checkbutton_4_settings_val.set(True)  # Enables saving to comicinfo
        app.process()

        app = ReadComicInfo(new_fileName_toAssert, ignore_empty_metadata=False).to_ComicInfo()

        with zipfile.ZipFile(new_fileName_toAssert, 'r') as zin:
            final_dir_count = len(zin.namelist())
        items_in_test_path_dir = os.listdir(test_path_dir)
        try:
            print(f"Aserting if renamed file exists in directory ({aseert_name} in Folder)")
            self.assertTrue(aseert_name in items_in_test_path_dir)
            print(f"Aserting if new volume numer in comicinfo is saved ({random_vol_number}=={app.get_Volume()})")
            self.assertEqual(random_vol_number, app.get_Volume())
        except AssertionError as e:
            self.zcleanup_test()
            raise e
        self.zcleanup_test()

    def z_test_zcount_leftover_files(self):
        final_dir_count = len(os.listdir(os.path.dirname(test_path)))
        print(f"Asserting {initial_dir_count} vs {final_dir_count}, delta 1")
        self.assertEqual(initial_dir_count, final_dir_count)

    def zcleanup_test(self):
        # Cleanup
        # Rename file to original name
        os.rename(final_cleanup_var1, original_cleanup_var1)


class Epub2CbzTester(unittest.TestCase):
    # TODO: This unit test needs to be rewritten. It's too messy
    def setUp(self) -> None:
        self.newEpubFileName = "TestEpub.epub"
        self.newEpubFilePath = rf"{os.getcwd()}/{self.newEpubFileName}"
        self.generatedImagesNumber = random.randint(1, 15)
        with ZipFile(self.newEpubFilePath, "w") as zout:
            for newFile_number in range(self.generatedImagesNumber):
                new_name = f"{newFile_number}".zfill(3)
                zout.write(sample_cover, f"images/{new_name}.jpg")

        self.root = tk.Tk()

    def test_convert(self):
        app = epub2cbz.App(self.root, [self.newEpubFilePath])
        app.output_folder = os.getcwd()

        newCbzPath = (os.getcwd() + "/" + self.newEpubFileName).replace(
            re.findall(r"(?i).*(\.[a-z]+$)", self.newEpubFilePath)[0]
            , ".cbz")
        app.start()
        app = None
        try:
            with ZipFile(newCbzPath, 'r') as zipCbz:
                print("")
                print(
                    f"Assert number of files in epub/images == files in cbz -> {len(zipCbz.namelist())}=={self.generatedImagesNumber}")
                self.assertEqual(len(zipCbz.namelist()), self.generatedImagesNumber)
        except AssertionError as e:
            os.remove(self.newEpubFilePath)
            os.remove(newCbzPath)
            raise e
        except PermissionError as e:
            print("Can't delete the files")
            raise e

        try:
            os.remove(self.newEpubFilePath)
            os.remove(newCbzPath)
        except Exception as e:
            pass


if __name__ == '__main__':
    unittest.main()
